#include <bits/stdc++.h>using namespace std;//Node of AVL Treestruct Node {    int data;    struct Node *left;    struct Node *right;    int height;};//Utility Function to get Heightint height(struct Node *N){    if(N==NULL)        return 0;    return N->height;}//Getting Maximum Element among twoint max(int a,int b){    if(a>b){        return a;    }    return b;}//Creating new_nodestruct Node* new_node(int data){    struct Node *node = (struct Node*)malloc(sizeof(struct Node));    node->data = data;    node->left = NULL;    node->right = NULL;    node->height = 1;    return node;}// Clockwise Rotationstruct Node* SingleRotateLefttoRight(struct Node* X){    struct Node *W = X->left;    struct Node *T = W->right;    W->right = X;    X->left = T;    X->height = max(height(X->left),height(X->right))+1;    W->height = max(height(W->left),height(W->right))+1;    return W;}//AntiClockwise Rotationstruct Node* SingleRotateRighttoLeft(struct Node* X){    struct Node *W = X->right;    struct Node *T = W->left;    W->left = X;    X->right = T;    X->height = max(height(X->left),height(X->right))+1;    W->height = max(height(W->right),X->height)+1;    return W;}//Checking Whether tree is balanced or notint getBalance(struct Node *X){    if(X==NULL)        return 0;    return height(X->left)-height(X->right);}//Insert Functionstruct Node* Insert(struct Node* root,int new_data) {    if (!root) {        return new_node(new_data);    }    if(new_data<root->data) {        root->left = Insert(root->left, new_data);    } else if(new_data>root->data){        root->right = Insert(root->right,new_data);    } else {        return root;    }    root->height = 1+max(height(root->left),height(root->right));    int balance = getBalance(root);    if(balance>1&&new_data<root->left->data)        return SingleRotateLefttoRight(root);    if(balance<-1&&new_data>root->right->data)        return SingleRotateRighttoLeft(root);    if(balance>1&&new_data>root->left->data)    {        root->left = SingleRotateRighttoLeft(root->left);        return SingleRotateLefttoRight(root);    }    if(balance<-1&&new_data<root->right->data)    {        root->right = SingleRotateLefttoRight(root->right);        return SingleRotateRighttoLeft(root);    }    return root;}//Printing in Preorder Fashionvoid preOrder(struct Node* root){    if(root != NULL)    {        printf("%d ", root->data);        preOrder(root->left);        preOrder(root->right);    }}struct Node* minelementnode(struct Node* root){    while(root->left!=NULL){        root=root->left;    }    return root;}struct Node* deletenode(struct Node* root,int data_del){    if(root == NULL)        return NULL;    if(data_del<root->data){        root->left = deletenode(root->left,data_del);    } else if(data_del>root->data){        root->right = deletenode(root->right,data_del);    } else {        if (root->left == NULL) {            struct Node *temp = root->right;            free(root);            return temp;        } else if (root->right == NULL) {            struct Node *temp = root->left;            free(root);            return temp;        }        struct Node *temp = minelementnode(root->right);        root->data = temp->data;        root->right = deletenode(root->right, temp->data);    }    if (root==NULL) {        return root;    }    root->height = 1+max(height(root->left),height(root->right));    int balance = getBalance(root);    if(balance>1&&getBalance(root->left)>=0)        return SingleRotateLefttoRight(root);    if(balance<-1&&getBalance(root->right)<=0)        return SingleRotateRighttoLeft(root);    if(balance>1&&getBalance(root->left)<0)    {        root->left = SingleRotateRighttoLeft(root->left);        return SingleRotateLefttoRight(root);    }    if(balance<-1&&getBalance(root->right)>0)    {        root->right = SingleRotateLefttoRight(root->right);        return SingleRotateRighttoLeft(root);    }    return root;}int main() {    struct Node* root = NULL;    while(1){        int s;        printf("\n Enter 1 for inserting \n Enter 2 for deleting \n Enter 3 to exit \n");        scanf("%d",&s);        switch(s){            case 1:{                int element;                printf("Enter element to insert ");                scanf("%d",&element);                root = Insert(root,element);                printf("\n Your Tree Becomes : - ");                preOrder(root);                break;            }            case 2:{                int element;                printf("Enter element to delete ");                scanf("%d",&element);                printf("\n Your Tree Becomes : - ");                root = deletenode(root,element);                preOrder(root);                break;            }            case 3:{                return 0;            }        }    }}